<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Spinner Wheel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            text-align: center;
        }

        h1 {
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .wheel-container {
            position: relative;
            width: 500px;
            height: 500px;
            margin: 0 auto 30px;
        }

        #wheel {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0,0,0,0.3);
            transition: transform 4s cubic-bezier(0.25, 0.1, 0.25, 1);
            border: 8px solid #fff;
        }

        .slice {
            position: absolute;
            width: 100%;
            height: 100%;
            clip-path: polygon(50% 50%, 50% 0%, 55% 0%);
            transform-origin: 50% 50%;
        }

        .slice-content {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 80px;
            background-repeat: no-repeat;
        }

        .slice-content span {
            position: relative;
            z-index: 1;
        }

        .arrow {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 40px solid #ff4444;
            filter: drop-shadow(0 3px 6px rgba(0,0,0,0.3));
            z-index: 10;
        }

        .center-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            z-index: 5;
        }

        #spinBtn {
            padding: 15px 40px;
            font-size: 1.3em;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s;
            font-weight: bold;
        }

        #spinBtn:hover:not(:disabled) {
            background: #ff6666;
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0,0,0,0.4);
        }

        #spinBtn:disabled {
            background: #999;
            cursor: not-allowed;
        }



        .winning-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .winning-image {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            animation: zoomIn 1s ease-out;
        }

        @keyframes zoomIn {
            from {
                transform: scale(0);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .info {
            color: white;
            margin-top: 20px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¯ Custom Spinner Wheel</h1>
        
        <div class="wheel-container">
            <div class="arrow"></div>
            <div id="wheel"></div>
            <div class="center-circle"></div>
        </div>

        <button id="spinBtn">SPIN THE WHEEL!</button>
        
        <p class="info">Spin count: <span id="spinCount">0</span> | Spins!</p>
    </div>

    <div class="winning-overlay" id="overlay">
        <img class="winning-image" id="winningImage" alt="Winner!">
    </div>

    <script>
        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', 
            '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2',
            '#F8B88B', '#ABEBC6'
        ];

        let spinCount = 0;
        let isSpinning = false;
        // Slices are created with -90Â° offset, so Slice 3 is at top initially
        // We want Slice 1 at top, so we need to rotate back by 2 slices = -72Â°
        // Plus the -18Â° centering offset = -90Â° total
        let currentRotation = -90; // Start with slice 1 centered at top
        let sliceImages = {};
        const riggedSlice = 5; // Third spin always lands on slice 5

        const wheel = document.getElementById('wheel');
        const spinBtn = document.getElementById('spinBtn');
        const spinCountDisplay = document.getElementById('spinCount');
        const overlay = document.getElementById('overlay');
        const winningImage = document.getElementById('winningImage');

        // Load images from the images folder
        // Images should be named IMG_001.WEBP through IMG_010.WEBP
        function loadImages() {
            for (let i = 1; i <= 10; i++) {
                const paddedNum = String(i).padStart(3, '0');
                sliceImages[i] = `images/IMG_${paddedNum}.WEBP`;
            }
        }

        loadImages();

        // Initialize wheel
        function createWheel() {
            wheel.innerHTML = '';
            const sliceAngle = 360 / 10;

            for (let i = 0; i < 10; i++) {
                const slice = document.createElement('div');
                slice.className = 'slice';
                
                // Create triangular wedge using clip-path
                const startAngle = i * sliceAngle;
                const endAngle = (i + 1) * sliceAngle;
                
                // Calculate points for triangular wedge
                const startRad = (startAngle - 90) * Math.PI / 180;
                const endRad = (endAngle - 90) * Math.PI / 180;
                
                const startX = 50 + 50 * Math.cos(startRad);
                const startY = 50 + 50 * Math.sin(startRad);
                const endX = 50 + 50 * Math.cos(endRad);
                const endY = 50 + 50 * Math.sin(endRad);
                
                slice.style.clipPath = `polygon(50% 50%, ${startX}% ${startY}%, ${endX}% ${endY}%)`;
                
                const sliceContent = document.createElement('div');
                sliceContent.className = 'slice-content';
                sliceContent.style.background = colors[i];
                sliceContent.style.transform = `rotate(${i * sliceAngle + sliceAngle / 2}deg)`;
                
                // Set background image if available
                if (sliceImages[i + 1]) {
                    sliceContent.style.backgroundImage = `url(${sliceImages[i + 1]})`;
                    sliceContent.style.backgroundSize = '120px auto'; // Scale thumbnail to fit nicely
                    sliceContent.style.backgroundPosition = 'center 60px'; // Position it in the slice
                }
                
                // Add slice number for debugging
                const sliceNumber = document.createElement('div');
                sliceNumber.style.position = 'absolute';
                sliceNumber.style.top = '20px';
                sliceNumber.style.left = '50%';
                sliceNumber.style.transform = 'translateX(-50%)';
                sliceNumber.style.color = 'white';
                sliceNumber.style.fontWeight = 'bold';
                sliceNumber.style.fontSize = '20px';
                sliceNumber.style.textShadow = '2px 2px 4px black';
                sliceNumber.textContent = i + 1;
                sliceContent.appendChild(sliceNumber);
                
                slice.appendChild(sliceContent);
                wheel.appendChild(slice);
            }
        }

        createWheel();
        
        // Set initial rotation so slice 1 is centered at the top
        wheel.style.transform = `rotate(${currentRotation}deg)`;
        
        console.log('=== WHEEL INITIALIZATION ===');
        console.log('Initial rotation:', currentRotation);
        console.log('Slice layout (i, slice number, start angle):');
        for (let i = 0; i < 10; i++) {
            const startAngle = i * 36 - 90;
            const centerAngle = startAngle + 18;
            console.log(`i=${i}, Slice ${i+1}, starts at ${startAngle}Â°, center at ${centerAngle}Â°`);
        }

        // Spin function
        spinBtn.addEventListener('click', function() {
            if (isSpinning) return;
            
            isSpinning = true;
            spinBtn.disabled = true;
            spinCount++;
            spinCountDisplay.textContent = spinCount;

            let targetSlice;
            
            // Check if this is the third spin (or 6th, 9th, etc.)
            if (spinCount % 3 === 0) {
                targetSlice = riggedSlice; // Always slice 5
            } else {
                targetSlice = Math.floor(Math.random() * 10) + 1;
            }

            // Calculate rotation
            const sliceAngle = 360 / 10; // 36 degrees per slice
            const baseRotation = 360 * 5; // 5 full spins for visual effect
            
            // For the rigged spin, calculate exact rotation to land on slice 5
            // For random spins, add a random offset within the target slice
            let additionalRotation;
            
            if (spinCount % 3 === 0) {
                // RIGGED SPIN - Calculate distance from current position to slice 5
                
                // First, normalize current rotation to 0-360 range
                const normalizedCurrentRotation = ((currentRotation % 360) + 360) % 360;
                
                // Slice 5's center position in the wheel (before any rotation)
                // Slice 5 (i=4): center at (4 * 36 - 90 + 18) = 72Â°
                const slice5CenterAngle = 72;
                
                // We want slice 5's center to end up at -90Â° (top position)
                // Current position of slice 5 after all previous rotations
                const slice5CurrentPosition = (slice5CenterAngle + normalizedCurrentRotation) % 360;
                
                // Target position for slice 5 center (top of wheel)
                const targetTopPosition = 270; // -90Â° = 270Â° in normalized form
                
                // Calculate shortest distance to rotate slice 5 to the top
                let distanceToSlice5 = targetTopPosition - slice5CurrentPosition;
                
                // Ensure we rotate forward (positive direction)
                if (distanceToSlice5 < 0) {
                    distanceToSlice5 += 360;
                }
                
                // Total rotation = 5 full spins + exact distance to slice 5
                additionalRotation = distanceToSlice5;
                
                console.log('=== RIGGED SPIN (Spin #' + spinCount + ') ===');
                console.log('Current normalized rotation:', normalizedCurrentRotation);
                console.log('Slice 5 current position:', slice5CurrentPosition);
                console.log('Distance to rotate to land on Slice 5:', distanceToSlice5);
                
            } else {
                // Random spin - pick a random slice and add random offset within that slice
                // Each slice spans 36Â°, we'll randomize within +/- 15Â° of center for variety
                const randomSliceCenter = (targetSlice - 1) * sliceAngle - 90 + (sliceAngle / 2);
                const randomOffset = (Math.random() - 0.5) * 30; // +/- 15 degrees
                const targetAngle = randomSliceCenter + randomOffset;
                
                // Calculate rotation needed to bring this angle to -90Â° (top)
                let rotationNeeded = -90 - targetAngle;
                
                // Normalize to positive rotation
                while (rotationNeeded <= 0) {
                    rotationNeeded += 360;
                }
                
                additionalRotation = rotationNeeded;
            }
            
            const totalRotation = baseRotation + additionalRotation;
            currentRotation += totalRotation;
            wheel.style.transform = `rotate(${currentRotation}deg)`;
            
            // Debug logging
            console.log('Target Slice:', targetSlice);
            console.log('Additional Rotation:', additionalRotation);
            console.log('Total Rotation (5 spins + distance):', totalRotation);
            console.log('New Current Rotation:', currentRotation);
            
            // After spinning, calculate which slice actually landed at the top
            setTimeout(() => {
                // Normalize current rotation to 0-360 range
                const normalizedRotation = ((currentRotation % 360) + 360) % 360;
                
                // The top of the wheel is at -90Â° in our coordinate system
                // Account for the wheel's rotation to find which slice is at top
                // A slice at position X is at the top when wheel rotates to (X - (-90))
                const topPosition = -90;
                
                // Calculate which slice is currently at the top
                // The slices are positioned: Slice 1 center at -72Â°, Slice 2 at -36Â°, etc.
                // After rotation, we need to find which slice center is closest to -90Â°
                
                // Effective position of each slice after rotation
                let landedSlice = 1;
                let minDistance = 360;
                
                for (let i = 1; i <= 10; i++) {
                    // Calculate where this slice's center is after rotation
                    const sliceBaseCenter = (i - 1) * sliceAngle - 90 + (sliceAngle / 2);
                    const sliceCurrentCenter = sliceBaseCenter + normalizedRotation;
                    const normalizedSliceCenter = ((sliceCurrentCenter % 360) + 360) % 360;
                    
                    // Calculate distance to top position (-90Â° or 270Â°)
                    let distance1 = Math.abs(normalizedSliceCenter - 270);
                    let distance2 = Math.abs(normalizedSliceCenter - (-90 + 360));
                    let distance = Math.min(distance1, distance2);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        landedSlice = i;
                    }
                }
                
                console.log('=== LANDED ===');
                console.log('Normalized Rotation:', normalizedRotation);
                console.log('Detected Landed Slice:', landedSlice);
                console.log('Image URL:', sliceImages[landedSlice]);
                
                isSpinning = false;
                spinBtn.disabled = false;
                
                // Show overlay with winning image - use the DETECTED slice
                winningImage.src = sliceImages[landedSlice];
                overlay.style.display = 'flex';
                
                // Hide overlay on click
                overlay.onclick = function() {
                    overlay.style.display = 'none';
                };
            }, 4000);
        });

        // Close overlay on click
        overlay.addEventListener('click', function() {
            this.style.display = 'none';
        });
    </script>
</body>
</html>
